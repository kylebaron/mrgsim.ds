---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ".",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# mrgsim.ds

<!-- badges: start -->
<!-- badges: end -->


`mrgsim.ds` provides an [Apache Arrow](https://arrow.apache.org/docs/r/)-backed 
simulation output object for [mrgsolve](https://mrgsolve.org), greatly reducing 
the memory footprint of large simulations and providing a high-performance 
pipeline for summarizing huge simulation outputs. The arrow-based simulation 
output objects in R claim ownership of their files on disk. 
Those files are automatically removed when the owning object goes out of scope 
and becomes subject to the R garbage collector. While "anonymous", 
parquet-formatted files hold the data in `tempdir()` while you are working in 
R, functions are provided to move your data to more permanent locations for 
later use. 


## Installation

You can install the development version of `mrgsim.ds` from 
[GitHub](https://github.com/kylebaron/mrgsim.ds) with:

``` r
# install.packages("devtools")
devtools::install_github("kylebaron/mrgsim.ds")
```

## Example 

We will illustrate `mrgsim.ds` by doing a simulation. 

```{r, message = FALSE}
library(mrgsim.ds)
library(dplyr)

mod <- modlib_ds("popex", end = 240, outvars = "IPRED,CL")

data <- expand.ev(amt = 100, ii = 24, total = 6, ID = 1:3000)
```

`mrgsim.ds` provides a new `mrgsim()` variant - `mrgsim_ds()`. The name implies 
we are tapping into Apache Arrow 
[Dataset](https://arrow.apache.org/docs/r/reference/Dataset.html) functionality.
The simulation below carries `1,446,000` rows.

```{r}
out <- mrgsim_ds(mod, data)

out
```


## Very lightweight simulation output object

The output object doesn't actually carry these 1.4M rows of simulated data. 
Rather it stores a pointer to the data in parquet files on your disk.


```{r}
basename(out$files)
```

This means there is almost nothing inside the object itself

```{r}
lobstr:::obj_size(out)

dim(out)
```

What if we did the same simulation with regular `mrgsim()`?

```{r}
x <- mrgsim(mod, data)

lobstr::obj_size(x)

dim(x)
```


The `mrgsim.ds` object is very light weight despite tracking the same data. 

## Handles like regular mrgsim output

But, we can do a lot of the typical things we would with any `mrgsim()` output 
object. 


```{r plot_head_tail_dim, fig.height = 4}
plot(out, nid = 12)
head(out)

tail(out)

dim(out)
```

This includes coercing to different types of objects. We can get the usual 
R data frames

```{r}
as_tibble(out)
```


Or stay in the arrow ecosystem

```{r}
as_arrow_ds(out)
```

Or try your hand at duckdb

```{r}
as_duckdb_ds(out)
```


## Tidyverse-friendly

We've integrated into the `dplyr` ecosystem as well, allowing you to `filter()`, 
`group_by()`, `mutate()`, or `select()` your way directly into a pipeline to 
summarize your simulations using the power of Apache Arrow.

```{r}
dd <- 
  out %>% 
  group_by(time) %>% 
  summarise(Mean = mean(IPRED, na.rm = TRUE), n = n()) %>% 
  arrange(time)

dd
```


```{r}
collect(dd)
```


## Good for large simulations

This workflow is particularly useful when running replicate simulations in 
parallel, with large outputs

```{r}
library(future.apply, quietly = TRUE)

plan(multisession, workers = 5L)

out2 <- future_lapply(1:10, \(x) { mrgsim_ds(mod, data) }, future.seed = TRUE)

out2 <- reduce_ds(out2)

out2
```


## Files on disk are automagically managed

All `arrow` files are stored in the `tempdir()` in parquet format

```{r}
list_temp()
```

This directory is eventually removed when the R session ends. Tools are provided
to manage the space.

```{r}
retain_temp(out2)

list_temp()
```


We also put a finalizer on each object so that, when it goes out of scope, 
the files are automatically cleaned up. 

```{r}
purge_temp()

plan(multisession, workers = 5L)

out1 <- mrgsim_ds(mod, data)
rename_ds(out1, "out1")

out2 <- future_lapply(1:10, \(x) { mrgsim_ds(mod, data) }, future.seed = TRUE)

out2 <- reduce_ds(out2)
rename_ds(out2, "out2")

out3 <- mrgsim_ds(mod, data) 
rename_ds(out3, "out3")
```

```{r}
list_temp()

rm(out2)
```

As soon as the garbage collector is called, the leftover files are cleaned up.
```{r}
gc()

list_temp()
```


### Ownership 

This setup is only possible if one object owns the files on disk and `mrgsim.ds`
tracks this.

```{r}
ownership()
```

If I make a copy of a simulation object, the old object no longer owns the 
files. 

```{r}
out4 <- copy_ds(out1, own = TRUE)

check_ownership(out1)

check_ownership(out4)
```

I can always take ownership back. 
```{r}
take_ownership(out1)

check_ownership(out1)

check_ownership(out4)
```




## If this is so great, why not make it the default for mrgsolve?

There is a cost to all of this. For small to mid-size simulations, you might 
see a small slowdown with `mrgsim_ds()`; it definitely won't be faster than 
`mrgsim()` ... even with the super-quick arrow ecosystem. This workflow is 
really for large simulation volumes where you are happy to pay the cost of 
writing outputs to file and then streaming them back in to summarize. 
