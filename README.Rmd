---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ".",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# mrgsim.ds

<!-- badges: start -->
<!-- badges: end -->


`mrgsim.ds` provides an [Apache Arrow](https://arrow.apache.org/docs/r/)-backed 
simulation output object for [mrgsolve](https://mrgsolve.org), greatly reducing 
the memory footprint of large simulations and providing a high-performance 
pipeline for summarizing huge simulation outputs.


## Installation

You can install the development version of `mrgsim.ds` from 
[GitHub](https://github.com/kylebaron/mrgsim.ds) with:

``` r
# install.packages("devtools")
devtools::install_github("kylebaron/mrgsim.ds")
```

## Example 

We will illustrate `mrgsim.ds` by doing a simulation. 

```{r, message = FALSE}
library(mrgsim.ds)
library(dplyr)

mod <- modlib_ds("popex", end = 240, outvars = c("IPRED,CL"))

data <- expand.ev(amt = 100, ii = 24, total = 6, ID = 1:3000)
```

`mrgsim.ds` provides a new `mrgsim()` variant - `mrgsim_ds()`. The name implies 
we are tapping into Apache Arrow 
[Dataset](https://arrow.apache.org/docs/r/reference/Dataset.html) functionality.

```{r}
out <- mrgsim_ds(mod, data)

out
```


## Very lightweight simulation output object

The output object doesn't actually carry the simulated data, but
rather a pointer to the data in parquet files on your disk.


```{r}
basename(out$files)
```

This means there is almost nothing inside the object itself

```{r}
lobstr:::obj_size(out)

dim(out)
```

What if we did the same simulation with regular `mrgsim()`?

```{r}
x <- mrgsim(mod, data)

lobstr::obj_size(x)

dim(x)
```


The object is very light weight despite carrying the same data. 

## Handles like regular mrgsim output

But, we can do a lot of the typical things we would with any `mrgsim()` output 
object. 


```{r plot_head_tail_dim, fig.height = 4}
plot(out, nid = 12)
head(out)

tail(out)

dim(out)
```

This includes coercing to different types of objects. We can get the usual 
R data frames

```{r}
as_tibble(out)
```


Or stay in the arrow ecosystem

```{r}
as_arrow_ds(out)
```

Or try your hand at duckdb

```{r}
as_duckdb_ds(out)
```


## Tidyverse-friendly

We've integrated into the `dplyr` ecosystem as well

```{r}
dd <- 
  out %>% 
  group_by(time) %>% 
  summarise(Mean = mean(IPRED, na.rm = TRUE))

dd
```


```{r}
collect(dd)
```


## Good for large simulations

This workflow is particularly useful when running replicate simulations in 
parallel, with large outputs

```{r}
library(future.apply, quietly = TRUE)

plan(multisession, workers = 5L)

out2 <- future_lapply(1:10, \(x) { mrgsim_ds(mod, data) }, future.seed = TRUE)

out2 <- reduce_ds(out2)

out2
```


## Files on disk are automagically managed

All `arrow` files are stored in the `tempdir()` in parquet format

```{r}
list_temp()
```

This directory is eventually removed when the R session ends. Tools are provided
to manage the space.

```{r}
retain_temp(out2)

list_temp()
```


We also put a finalizer on each object so that, when it goes out of scope, 
the files are automatically cleaned up. 

```{r}
purge_temp()

plan(multisession, workers = 5L)

out1 <- mrgsim_ds(mod, data) %>% rename_ds("out1")

out2 <- future_lapply(1:10, \(x) { mrgsim_ds(mod, data) }, future.seed = TRUE)

out2 <- reduce_ds(out2) %>% rename_ds("out2")

out3 <- mrgsim_ds(mod, data) %>% rename_ds("out3")
```


```{r}
list_temp()

rm(out2)
```

As soon as the garbage collecter is called, the leftover files are cleaned up.
```{r}
gc()

list_temp()
```

